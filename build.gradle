import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.plugins.ide.eclipse.model.SourceFolder
import org.gradle.plugins.signing.Sign

plugins {
    alias(libs.plugins.axion.release)
    id 'java'
    id 'application'
    id 'maven-publish'
    id 'signing'
    id 'eclipse'
    alias(libs.plugins.jib)
    alias(libs.plugins.nmcp)
    alias(libs.plugins.shadow)
    id 'idea'
    id 'ai.pipestream.proto-toolchain' version '0.7.3'
}

scmVersion {
    tag {
        prefix = 'v'
    }
    checks {
        uncommittedChanges = false
        aheadOfRemote = false
        snapshotDependencies = false
    }
}

group = 'ai.pipestream'
version = scmVersion.version

repositories {
    mavenLocal()
    mavenCentral()
    // Maven Central snapshots host ai.pipestream SNAPSHOTs
    maven {
        url = uri('https://central.sonatype.com/repository/maven-snapshots/')
        mavenContent {
            snapshotsOnly()
        }
    }
}

def protobufVersion = libs.versions.protobuf.java.get()

configurations.configureEach {
    resolutionStrategy {
        force "com.google.protobuf:protobuf-java:${protobufVersion}"
        force "com.google.protobuf:protobuf-java-util:${protobufVersion}"
    }
}

// Proto toolchain configuration - fetches from Git and generates Java/gRPC code
pipestreamProtos {
    sourceMode = 'git'
    generateMutiny = false  // Not a Quarkus project
    generateDescriptors = true
    descriptorPath = layout.buildDirectory.file("descriptors/services.dsc")

    modules {
        register("common") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "common"
        }
        register("pipeline-module") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "pipeline-module"
        }
        register("config") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "config"
        }
        register("admin") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "admin"
        }
        register("intake") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "intake"
        }
        register("parser") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "parser"
        }
        register("opensearch") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "opensearch"
        }
        register("ui-ux") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "ui-ux"
        }
        register("registration") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "registration"
        }
        register("engine") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "engine"
        }
        register("linear-processor") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "linear-processor"
        }
        register("testing-harness") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "testing-harness"
        }
        register("design") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "design"
        }
        register("repo") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "repo"
        }
    }
}

dependencies {
    implementation libs.wiremock
    implementation("org.wiremock:wiremock-grpc-extension:1.0.0-beta.3") {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
    }

    implementation libs.slf4j.simple

    implementation libs.protobuf.java
    implementation libs.protobuf.java.util

    // gRPC runtime dependencies for the custom server
    implementation libs.grpc.netty
    implementation libs.grpc.protobuf
    implementation libs.grpc.stub
    implementation libs.grpc.services
    compileOnly libs.javax.annotation.api

    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:6.0.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

// Configure source sets for proto-toolchain generated code
sourceSets {
    main {
        java {
            srcDir layout.buildDirectory.dir("generated/source/proto/main/java")
        }
    }
}

// Configure IntelliJ IDEA to recognize generated sources
idea {
    module {
        sourceDirs += file('build/generated/source/proto/main/java')
        generatedSourceDirs += file('build/generated/source/proto/main/java')
    }
}

// Configure Eclipse to recognize generated sources
eclipse {
    classpath {
        file {
            whenMerged { classpath ->
                // Add generated protobuf sources to Eclipse classpath
                def generatedJava = new SourceFolder(
                    'build/generated/source/proto/main/java', null)
                classpath.entries.add(generatedJava)
            }
        }
    }
}

tasks.named('processResources').configure {
    dependsOn 'generateProtos'
}

// Shadow JAR configuration for Docker container - replaces the jar task
shadowJar {
    // Use a distinct classifier so we can target the correct artifact in Docker
    archiveClassifier = 'all'
    // Ensure a stable filename
    archiveBaseName.set('pipestream-wiremock-server')
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'ai.pipestream.wiremock.server.Main'
    }
}

// Disable default JAR since shadowJar replaces it
jar {
    enabled = false
}

// Make build and distribution tasks depend on shadowJar
tasks.named('build').configure {
    dependsOn shadowJar
}
distTar.dependsOn shadowJar
distZip.dependsOn shadowJar
startScripts.dependsOn shadowJar

tasks.named('processTestResources').configure {
    dependsOn 'generateProtos', 'buildDescriptors'
    // Copy descriptor file to test resources wiremock/grpc so WireMock gRPC extension can find it in tests
    // WireMock expects it at src/test/resources/wiremock/grpc/services.dsc when using withRootDirectory
    doLast {
        def descriptorFile = layout.buildDirectory.file("descriptors/services.dsc").get().asFile
        if (descriptorFile.exists()) {
            // Copy to wiremock/grpc directory for withRootDirectory approach
            copy {
                from descriptorFile
                into "${projectDir}/src/test/resources/wiremock/grpc"
            }
            // Also copy to grpc for classpath approach
            copy {
                from descriptorFile
                into layout.buildDirectory.dir("resources/test/grpc").get().asFile
            }
        }
        // Copy ServiceLoader service file to test resources
        def serviceFile = file("${projectDir}/src/main/resources/META-INF/services/ai.pipestream.wiremock.client.ServiceMockInitializer")
        if (serviceFile.exists()) {
            copy {
                from serviceFile
                into "${projectDir}/src/test/resources/META-INF/services"
            }
        }

        // Copy mappings to test resources so they are available on classpath at /mappings
        def mappingsDir = file("${projectDir}/src/main/resources/mappings")
        if (mappingsDir.exists()) {
            copy {
                from mappingsDir
                into layout.buildDirectory.dir("resources/test/mappings").get().asFile
            }
        }
    }
}

// Explicit dependencies to resolve Gradle 8+ validation errors
tasks.withType(Jar).configureEach {
    dependsOn 'generateProtos'
}
tasks.withType(Javadoc).configureEach {
    dependsOn 'generateProtos'
}

application {
    mainClass = 'ai.pipestream.wiremock.server.Main'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
    withJavadocJar()
    withSourcesJar()
}

// Handle duplicate source files from multi-module proto generation
tasks.named('sourcesJar').configure {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

test {
    useJUnitPlatform()
    maxHeapSize = "8g"
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true
    }
}

// Configure Javadoc task
tasks.withType(Javadoc).configureEach { task ->
    def opts = task.options
    opts.encoding = 'UTF-8'
    opts.charSet = 'UTF-8'
    opts.locale = 'en'
    if (opts instanceof StandardJavadocDocletOptions) {
        opts.addBooleanOption('html5', true)
    }
    // Suppress missing Javadoc warnings for now to ensure build passes but produces valid artifacts
    opts.addStringOption('Xdoclint:-missing', '-quiet')
    
    // Exclude generated protobuf code from Javadoc
    task.exclude('**/ai/pipestream/platform/registration/**') 
    task.exclude('**/ai/pipestream/data/**')
    task.exclude('**/ai/pipestream/opensearch/**')
    task.exclude('**/com/google/**')
}

// Publishing configuration
publishing {
    publications {
        create('maven', MavenPublication) {
            // Manually specify artifacts since jar task is disabled
            artifact shadowJar
            artifact sourcesJar
            artifact javadocJar
            pom {
                name.set('Pipestream WireMock Server')
                description.set('Standalone WireMock server with gRPC extension and custom streaming support for Pipestream')
                url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')

                licenses {
                    license {
                        name.set('MIT License')
                        url.set('https://opensource.org/license/mit')
                    }
                }

                developers {
                    developer {
                        id.set('krickert')
                        name.set('Pipestream Engine Team')
                    }
                }

                scm {
                    connection.set('scm:git:git://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    developerConnection.set('scm:git:ssh://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')
                }
            }
        }
    }

    repositories {
        mavenLocal()
        
        def ghRepo = System.getenv('GITHUB_REPOSITORY') ?: 'ai-pipestream/pipestream-wiremock-server'
        def ghActor = System.getenv('GITHUB_ACTOR') ?: System.getenv('GPR_USER')
        def ghToken = System.getenv('GITHUB_TOKEN') ?: System.getenv('GPR_TOKEN')
        
        if (ghActor && ghToken) {
            maven {
                name = 'GitHubPackages'
                url = uri("https://maven.pkg.github.com/${ghRepo}")
                credentials {
                    username = ghActor
                    password = ghToken
                }
            }
        }
    }
}

signing {
    def signingKey = System.getenv("GPG_PRIVATE_KEY")
    def signingPassword = System.getenv("GPG_PASSPHRASE")

    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.maven
    }
}

// Ensure all signing tasks run before nmcp bundles and publishes artifacts
afterEvaluate {
    tasks.matching { it.name.startsWith("nmcpZipAllPublications") || it.name.startsWith("nmcpPublishAllPublicationsToCentralPortal") }
        .configureEach { nmcpTask ->
            nmcpTask.dependsOn(tasks.withType(Sign))
        }
}

nmcp {
    publishAllPublicationsToCentralPortal {
        username = providers.environmentVariable("MAVEN_CENTRAL_USERNAME")
        password = providers.environmentVariable("MAVEN_CENTRAL_PASSWORD")
        publishingType = "AUTOMATIC"
    }
}

jib {
    from {
        image = 'eclipse-temurin:21-jre'
        platforms {
            platform {
                architecture = 'amd64'
                os = 'linux'
            }
            platform {
                architecture = 'arm64'
                os = 'linux'
            }
        }
    }
    to {
        image = 'pipestream/pipestream-wiremock-server'
        tags = ['latest']
    }
    container {
        mainClass = 'ai.pipestream.wiremock.server.Main'
        creationTime = 'USE_CURRENT_TIMESTAMP'
        jvmFlags = ['-Djava.security.egd=file:/dev/./urandom']
        ports = ['8080', '50052']
        user = '185'
    }
}

