import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.plugins.signing.Sign

plugins {
    alias(libs.plugins.axion.release)
    id 'java'
    id 'application'
    id 'maven-publish'
    id 'signing'
    alias(libs.plugins.jib)
    alias(libs.plugins.protobuf)
    alias(libs.plugins.nmcp)
}

scmVersion {
    tag {
        prefix = 'v'
    }
    checks {
        uncommittedChanges = false
        aheadOfRemote = false
        snapshotDependencies = false
    }
}

group = 'ai.pipestream'
version = scmVersion.version

repositories {
    mavenLocal()
    mavenCentral()
    // Maven Central snapshots host ai.pipestream SNAPSHOTs
    maven {
        url = uri('https://central.sonatype.com/repository/maven-snapshots/')
        mavenContent {
            snapshotsOnly()
        }
    }
}

def protobufVersion = libs.versions.protobuf.java.get()
def grpcVersion = libs.versions.grpc.get()

// Define where we want to download the schemas from Buf Registry
def bufExportDir = layout.buildDirectory.dir("generated/buf-protos")

configurations.configureEach {
    resolutionStrategy {
        force "com.google.protobuf:protobuf-java:${protobufVersion}"
        force "com.google.protobuf:protobuf-java-util:${protobufVersion}"
    }
}

// Task to sync proto files from Buf Schema Registry
// This replaces the Maven artifact dependency on pipestream-protos
tasks.register('syncProtos', Exec) {
    group = 'protobuf'
    description = 'Exports proto files from the Buf Registry'

    // Buf module to fetch - can be made configurable via -PbufModule or -PbufVersion
    def bufModule = project.findProperty('bufModule') ?: 'buf.build/pipestreamai/platform'

    // Command: buf export <module> --output <dir>
    // This downloads the raw .proto files, preserving the directory structure
    commandLine 'buf', 'export', bufModule, '--output', bufExportDir.get().asFile.path

    // Gradle will skip this if the output exists and inputs haven't changed
    outputs.dir(bufExportDir)

    doFirst {
        // Ensure output directory exists
        bufExportDir.get().asFile.mkdirs()
    }
}

dependencies {
    implementation libs.wiremock
    implementation(libs.wiremock.grpc.extension.standalone) {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
    }

    implementation libs.slf4j.simple

    implementation libs.protobuf.java
    implementation libs.protobuf.java.util

    // gRPC runtime dependencies for the custom server
    implementation libs.grpc.netty
    implementation libs.grpc.protobuf
    implementation libs.grpc.stub
    compileOnly libs.javax.annotation.api

    // Proto files are now fetched from Buf Registry via syncProtos task
    // Keep Google Common Protos as library to avoid conflicts with protobuf-java-util
    protobuf libs.proto.google.common.protos
}

protobuf {
    protoc {
        // Use an older protoc that matches our forced runtime
        artifact = "com.google.protobuf:protoc:${protobufVersion}"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
        }
    }
    generateProtoTasks {
        ofSourceSet('main').each { task ->
            task.generateDescriptorSet = true
            task.descriptorSetOptions.includeImports = true
            // Output the descriptor to a generated resources directory
            task.descriptorSetOptions.path = layout.buildDirectory.file("generated/resources/proto/main/META-INF/grpc/services.dsc").get().asFile.path

            task.plugins {
                grpc {}
            }
        }
    }
}

// Configure source sets
sourceSets {
    main {
        proto {
            // Tell Gradle's Protobuf Plugin to look in the buf-exported folder
            srcDir bufExportDir
        }
        resources {
            // Add the generated descriptor set to resources
            srcDir layout.buildDirectory.dir("generated/resources/proto/main")
        }
    }
}

tasks.named('processResources').configure {
    dependsOn 'generateProto'
}

// Wire up task dependencies
// Before you generate Java code, you must fetch the protos from Buf
tasks.named('generateProto').configure {
    dependsOn 'syncProtos'

    doFirst {
        mkdir layout.buildDirectory.dir("generated/resources/proto/main/META-INF/grpc").get().asFile
    }
}

// Explicit dependencies to resolve Gradle 8+ validation errors
tasks.withType(Jar).configureEach {
    dependsOn 'generateProto'
}
tasks.withType(Javadoc).configureEach {
    dependsOn 'generateProto'
}

application {
    mainClass = 'ai.pipestream.wiremock.server.Main'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
    withJavadocJar()
    withSourcesJar()
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

// Configure Javadoc task
tasks.withType(Javadoc).configureEach { task ->
    def opts = task.options
    opts.encoding = 'UTF-8'
    opts.charSet = 'UTF-8'
    opts.locale = 'en'
    if (opts instanceof StandardJavadocDocletOptions) {
        opts.addBooleanOption('html5', true)
    }
    // Suppress missing Javadoc warnings for now to ensure build passes but produces valid artifacts
    opts.addStringOption('Xdoclint:-missing', '-quiet')
    
    // Exclude generated protobuf code from Javadoc
    task.exclude('**/ai/pipestream/platform/registration/**') 
    task.exclude('**/ai/pipestream/data/**')
    task.exclude('**/ai/pipestream/opensearch/**')
    task.exclude('**/com/google/**')
}

jib {
    to {
        image = 'ghcr.io/ai-pipestream/pipestream-wiremock-server'
        tags = ['latest', version]
    }
    container {
        mainClass = 'ai.pipestream.wiremock.server.Main'
        ports = ['8080', '50051', '50052'] // HTTP, gRPC, and Streaming gRPC ports
        jvmFlags = ['-Djava.awt.headless=true']
    }
}

// Publishing configuration
publishing {
    publications {
        create('maven', MavenPublication) {
            from components.java
            pom {
                name.set('Pipestream WireMock Server')
                description.set('Standalone WireMock server with gRPC extension and custom streaming support for Pipestream')
                url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')

                licenses {
                    license {
                        name.set('MIT License')
                        url.set('https://opensource.org/license/mit')
                    }
                }

                developers {
                    developer {
                        id.set('krickert')
                        name.set('Pipestream Engine Team')
                    }
                }

                scm {
                    connection.set('scm:git:git://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    developerConnection.set('scm:git:ssh://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')
                }
            }
        }
    }

    repositories {
        mavenLocal()
        
        def ghRepo = System.getenv('GITHUB_REPOSITORY') ?: 'ai-pipestream/pipestream-wiremock-server'
        def ghActor = System.getenv('GITHUB_ACTOR') ?: System.getenv('GPR_USER')
        def ghToken = System.getenv('GITHUB_TOKEN') ?: System.getenv('GPR_TOKEN')
        
        if (ghActor && ghToken) {
            maven {
                name = 'GitHubPackages'
                url = uri("https://maven.pkg.github.com/${ghRepo}")
                credentials {
                    username = ghActor
                    password = ghToken
                }
            }
        }
    }
}

signing {
    def signingKey = System.getenv("GPG_PRIVATE_KEY")
    def signingPassword = System.getenv("GPG_PASSPHRASE")

    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.maven
    }
}

// Ensure all signing tasks run before nmcp bundles and publishes artifacts
afterEvaluate {
    tasks.matching { it.name.startsWith("nmcpZipAllPublications") || it.name.startsWith("nmcpPublishAllPublicationsToCentralPortal") }
        .configureEach { nmcpTask ->
            nmcpTask.dependsOn(tasks.withType(Sign))
        }
}

nmcp {
    publishAllPublicationsToCentralPortal {
        username = providers.environmentVariable("MAVEN_CENTRAL_USERNAME")
        password = providers.environmentVariable("MAVEN_CENTRAL_PASSWORD")
        publishingType = "AUTOMATIC"
    }
}
