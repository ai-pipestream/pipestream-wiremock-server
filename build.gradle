import org.gradle.plugins.ide.eclipse.model.SourceFolder

import java.nio.file.Files
import java.nio.file.StandardCopyOption

plugins {
    alias(libs.plugins.axion.release)
    id 'java'
    id 'application'
    id 'maven-publish'
    id 'signing'
    id 'eclipse'
    alias(libs.plugins.jib)
    alias(libs.plugins.nmcp)
    alias(libs.plugins.shadow)
    id 'idea'
    id 'ai.pipestream.proto-toolchain' version '0.7.10'
}

scmVersion {
    tag {
        prefix = 'v'
    }
    checks {
        uncommittedChanges = false
        aheadOfRemote = false
        snapshotDependencies = false
    }
}

group = 'ai.pipestream'
version = scmVersion.version

repositories {
    mavenLocal()
    mavenCentral()
    // Maven Central snapshots host ai.pipestream SNAPSHOTs
    maven {
        url = uri('https://central.sonatype.com/repository/maven-snapshots/')
        mavenContent {
            snapshotsOnly()
        }
    }
}

def protobufVersion = libs.versions.protobuf.java.get()

configurations.configureEach {
    resolutionStrategy {
        force "com.google.protobuf:protobuf-java:${protobufVersion}"
        force "com.google.protobuf:protobuf-java-util:${protobufVersion}"
    }
}

// Proto toolchain configuration - fetches from Git and generates Java/gRPC code
pipestreamProtos {
    sourceMode = 'git'
    generateMutiny = false  // Not a Quarkus project
    generateDescriptors = true
    descriptorPath = layout.buildDirectory.file("descriptors/services.dsc")
    // Automatically copy descriptors to test build resources (build directory only)
    copyDescriptorsToResources = true
    testBuildDir = layout.buildDirectory.dir("resources/test/wiremock/grpc")

    modules {
        register("all") {
            gitRepo = "https://github.com/ai-pipestream/pipestream-protos.git"
            gitRef = "main"
            gitSubdir = "."
        }
    }
}

dependencies {
    implementation libs.wiremock.core
    implementation("org.wiremock:wiremock-grpc-extension:1.0.0-beta.4") {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
    }

    implementation libs.slf4j.simple
    implementation libs.jboss.logging

    implementation libs.protobuf.java.core
    implementation libs.protobuf.java.util

    // gRPC runtime dependencies for the custom server
    implementation libs.grpc.netty
    implementation libs.grpc.protobuf
    implementation libs.grpc.stub
    implementation libs.grpc.services
    compileOnly libs.javax.annotation.api

    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:6.0.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

// Configure source sets for proto-toolchain generated code
sourceSets {
    main {
        java {
            srcDir layout.buildDirectory.dir("generated/source/proto/main/java")
        }
    }
}

// Configure IntelliJ IDEA to recognize generated sources
idea {
    module {
        sourceDirs += file('build/generated/source/proto/main/java')
        generatedSourceDirs += file('build/generated/source/proto/main/java')
    }
}

// Configure Eclipse to recognize generated sources
eclipse {
    classpath {
        file {
            whenMerged { classpath ->
                // Add generated protobuf sources to Eclipse classpath
                def generatedJava = new SourceFolder(
                    'build/generated/source/proto/main/java', null)
                classpath.entries.add(generatedJava)
            }
        }
    }
}

tasks.named('processResources').configure {
    dependsOn 'generateProtos', 'buildDescriptors'
    from(layout.buildDirectory.dir("descriptors")) {
        into "wiremock/grpc"
    }
}

// Shadow JAR configuration for Docker container - replaces the jar task
shadowJar {
    // Use a distinct classifier so we can target the correct artifact in Docker
    archiveClassifier = 'all'
    // Ensure a stable filename
    archiveBaseName.set('pipestream-wiremock-server')
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'ai.pipestream.wiremock.server.Main'
    }
}

// Disable default JAR since shadowJar replaces it
jar {
    enabled = false
}

// Make build and distribution tasks depend on shadowJar
tasks.named('build').configure {
    dependsOn shadowJar
}
distTar.dependsOn shadowJar
distZip.dependsOn shadowJar
startScripts.dependsOn shadowJar

// Capture paths during configuration phase for configuration cache compatibility
def projectDirPath = project.layout.projectDirectory.asFile.absolutePath

tasks.named('processTestResources').configure {
    dependsOn 'generateProtos', 'buildDescriptors', 'copyDescriptorsToResources'

    // Copy protobuf descriptors to test resources for WireMock
    from(layout.buildDirectory.dir("descriptors")) {
        into "wiremock/grpc"
    }

    // Copy mappings from main resources to test resources
    from("src/main/resources/wiremock/mappings") {
        into "wiremock/mappings"
    }

    // Copy ServiceLoader service file
    doLast {
        def serviceFile = new File("${projectDirPath}/src/main/resources/META-INF/services/ai.pipestream.wiremock.client.ServiceMockInitializer")
        if (serviceFile.exists()) {
            def targetDir = new File("${projectDirPath}/src/test/resources/META-INF/services")
            targetDir.mkdirs()
            Files.copy(
                serviceFile.toPath(),
                new File(targetDir, serviceFile.name).toPath(),
                    StandardCopyOption.REPLACE_EXISTING
            )
        }
    }
}

// Explicit dependencies to resolve Gradle 8+ validation errors
tasks.withType(Jar).configureEach {
    dependsOn 'generateProtos'
}
tasks.withType(Javadoc).configureEach {
    dependsOn 'generateProtos'
}

application {
    mainClass = 'ai.pipestream.wiremock.server.Main'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
    withJavadocJar()
    withSourcesJar()
}

// Handle duplicate source files from multi-module proto generation
tasks.named('sourcesJar').configure {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

test {
    useJUnitPlatform()
    // 5GB heap is sufficient for the 1.2GB payload test and fits within
    // GitHub Actions standard runners (7GB total RAM)
    maxHeapSize = "5g"
    // Run test classes sequentially to avoid XML test result file writing conflicts
    // This is a known issue when multiple test forks write to the same XML files simultaneously
    // With only 6 test classes, the performance impact is minimal
    maxParallelForks = 1
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
        showStandardStreams = true
    }
}

// Configure Javadoc task
tasks.withType(Javadoc).configureEach { task ->
    def opts = task.options
    opts.encoding = 'UTF-8'
    opts.charSet = 'UTF-8'
    opts.locale = 'en'
    if (opts instanceof StandardJavadocDocletOptions) {
        opts.addBooleanOption('html5', true)
    }
    // Suppress missing Javadoc warnings for now to ensure build passes but produces valid artifacts
    opts.addStringOption('Xdoclint:-missing', '-quiet')
    
    // Exclude generated protobuf code from Javadoc
    task.exclude('**/ai/pipestream/platform/registration/**') 
    task.exclude('**/ai/pipestream/data/**')
    task.exclude('**/ai/pipestream/opensearch/**')
    task.exclude('**/com/google/**')
}

// Publishing configuration
publishing {
    publications {
        create('maven', MavenPublication) {
            // Manually specify artifacts since jar task is disabled
            artifact shadowJar
            artifact sourcesJar
            artifact javadocJar
            pom {
                name.set('Pipestream WireMock Server')
                description.set('Standalone WireMock server with gRPC extension and custom streaming support for Pipestream')
                url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')

                licenses {
                    license {
                        name.set('MIT License')
                        url.set('https://opensource.org/license/mit')
                    }
                }

                developers {
                    developer {
                        id.set('krickert')
                        name.set('Pipestream Engine Team')
                    }
                }

                scm {
                    connection.set('scm:git:git://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    developerConnection.set('scm:git:ssh://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')
                }
            }
        }
    }

    repositories {
        mavenLocal()
        
        def ghRepo = System.getenv('GITHUB_REPOSITORY') ?: 'ai-pipestream/pipestream-wiremock-server'
        def ghActor = System.getenv('GITHUB_ACTOR') ?: System.getenv('GPR_USER')
        def ghToken = System.getenv('GITHUB_TOKEN') ?: System.getenv('GPR_TOKEN')
        
        if (ghActor && ghToken) {
            maven {
                name = 'GitHubPackages'
                url = uri("https://maven.pkg.github.com/${ghRepo}")
                credentials {
                    username = ghActor
                    password = ghToken
                }
            }
        }
    }
}

signing {
    def signingKey = System.getenv("GPG_PRIVATE_KEY")
    def signingPassword = System.getenv("GPG_PASSPHRASE")

    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.maven
    }
}

// Ensure all signing tasks run before nmcp bundles and publishes artifacts
afterEvaluate {
    tasks.matching { it.name.startsWith("nmcpZipAllPublications") || it.name.startsWith("nmcpPublishAllPublicationsToCentralPortal") }
        .configureEach { nmcpTask ->
            nmcpTask.dependsOn(tasks.withType(Sign))
        }
}

nmcp {
    publishAllPublicationsToCentralPortal {
        username = providers.environmentVariable("MAVEN_CENTRAL_USERNAME")
        password = providers.environmentVariable("MAVEN_CENTRAL_PASSWORD")
        publishingType = "AUTOMATIC"
    }
}

jib {
    from {
        image = 'eclipse-temurin:21-jre'
        platforms {
            platform {
                architecture = 'amd64'
                os = 'linux'
            }
            platform {
                architecture = 'arm64'
                os = 'linux'
            }
        }
    }
    to {
        image = 'pipestream/pipestream-wiremock-server'
        tags = ['latest']
    }
    container {
        mainClass = 'ai.pipestream.wiremock.server.Main'
        creationTime = 'USE_CURRENT_TIMESTAMP'
        jvmFlags = ['-Djava.security.egd=file:/dev/./urandom']
        ports = ['8080', '50052']
        user = '185'
    }
}

