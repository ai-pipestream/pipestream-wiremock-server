import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.plugins.signing.Sign

plugins {
    alias(libs.plugins.axion.release)
    id 'java'
    id 'application'
    id 'maven-publish'
    id 'signing'
    id 'eclipse'
    alias(libs.plugins.jib)
    alias(libs.plugins.protobuf)
    alias(libs.plugins.nmcp)
    alias(libs.plugins.shadow)
    id 'idea'
}

scmVersion {
    tag {
        prefix = 'v'
    }
    checks {
        uncommittedChanges = false
        aheadOfRemote = false
        snapshotDependencies = false
    }
}

group = 'ai.pipestream'
version = scmVersion.version

repositories {
    mavenLocal()
    mavenCentral()
    // Maven Central snapshots host ai.pipestream SNAPSHOTs
    maven {
        url = uri('https://central.sonatype.com/repository/maven-snapshots/')
        mavenContent {
            snapshotsOnly()
        }
    }
}

def protobufVersion = libs.versions.protobuf.java.get()
def grpcVersion = libs.versions.grpc.get()

// Define where we want to download the schemas from Buf Registry
def bufExportDir = layout.buildDirectory.dir("generated/buf-protos")

configurations.configureEach {
    resolutionStrategy {
        force "com.google.protobuf:protobuf-java:${protobufVersion}"
        force "com.google.protobuf:protobuf-java-util:${protobufVersion}"
    }
}

// Task to sync proto files from Buf Schema Registry
// This replaces the Maven artifact dependency on pipestream-protos
// All modules are synced in dependency order to ensure proper resolution

// Base module with no dependencies
tasks.register('syncCommonProtos', Exec) {
    group = 'protobuf'
    description = 'Exports common proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/common',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    doFirst {
        bufExportDir.get().asFile.mkdirs()
    }
}

// Modules that depend only on common
tasks.register('syncPipelineModuleProtos', Exec) {
    group = 'protobuf'
    description = 'Exports pipeline-module proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/pipeline-module',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncConfigProtos', Exec) {
    group = 'protobuf'
    description = 'Exports config proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/config',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncAdminProtos', Exec) {
    group = 'protobuf'
    description = 'Exports admin proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/admin',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncIntakeProtos', Exec) {
    group = 'protobuf'
    description = 'Exports intake proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/intake',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncParserProtos', Exec) {
    group = 'protobuf'
    description = 'Exports parser proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/parser',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncOpensearchProtos', Exec) {
    group = 'protobuf'
    description = 'Exports opensearch proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/opensearch',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

tasks.register('syncUiUxProtos', Exec) {
    group = 'protobuf'
    description = 'Exports ui-ux proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/ui-ux',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncCommonProtos'
}

// Modules that depend on common + pipeline-module
tasks.register('syncRegistrationProtos', Exec) {
    group = 'protobuf'
    description = 'Exports registration proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/registration',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncPipelineModuleProtos'
}

tasks.register('syncEngineProtos', Exec) {
    group = 'protobuf'
    description = 'Exports engine proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/engine',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncPipelineModuleProtos'
}

tasks.register('syncLinearProcessorProtos', Exec) {
    group = 'protobuf'
    description = 'Exports linear-processor proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/linear-processor',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncPipelineModuleProtos'
}

tasks.register('syncTestingHarnessProtos', Exec) {
    group = 'protobuf'
    description = 'Exports testing-harness proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/testing-harness',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncPipelineModuleProtos'
}

// Modules that depend on common + config
tasks.register('syncDesignProtos', Exec) {
    group = 'protobuf'
    description = 'Exports design proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/design',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncConfigProtos'
}

// Modules that depend on common + pipeline-module + config
tasks.register('syncRepoProtos', Exec) {
    group = 'protobuf'
    description = 'Exports repo proto files from Buf Registry'
    commandLine 'buf', 'export', 'buf.build/pipestreamai/repo',
            '--output', bufExportDir.get().asFile.path
    outputs.dir(bufExportDir)
    dependsOn 'syncConfigProtos', 'syncPipelineModuleProtos'
}

// Aggregate task that syncs all protos
tasks.register('syncProtos') {
    group = 'protobuf'
    description = 'Syncs all proto definitions from Buf Registry'
    dependsOn 'syncCommonProtos',
            'syncPipelineModuleProtos',
            'syncConfigProtos',
            'syncAdminProtos',
            'syncIntakeProtos',
            'syncParserProtos',
            'syncOpensearchProtos',
            'syncUiUxProtos',
            'syncRegistrationProtos',
            'syncEngineProtos',
            'syncLinearProcessorProtos',
            'syncTestingHarnessProtos',
            'syncDesignProtos',
            'syncRepoProtos'
}

dependencies {
    implementation libs.wiremock
    implementation("org.wiremock:wiremock-grpc-extension:1.0.0-beta.3") {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
    }

    implementation libs.slf4j.simple

    implementation libs.protobuf.java
    implementation libs.protobuf.java.util

    // gRPC runtime dependencies for the custom server
    implementation libs.grpc.netty
    implementation libs.grpc.protobuf
    implementation libs.grpc.stub
    compileOnly libs.javax.annotation.api

    // Proto files are now fetched from Buf Registry via syncProtos task
    // Keep Google Common Protos as library to avoid conflicts with protobuf-java-util
    protobuf libs.proto.google.common.protos

    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:6.0.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

protobuf {
    protoc {
        // Use an older protoc that matches our forced runtime
        artifact = "com.google.protobuf:protoc:${protobufVersion}"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
        }
    }
    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
        all().each { task ->
            task.generateDescriptorSet = true
            task.descriptorSetOptions.includeSourceInfo = true
            task.descriptorSetOptions.includeImports = true
            // Generate descriptor directly to wiremock/grpc directory (like reference examples)
            // This ensures WireMock can find it when using withRootDirectory("src/test/resources/wiremock")
            task.descriptorSetOptions.path = "$projectDir/src/test/resources/wiremock/grpc/services.dsc"
        }
    }
}

// Configure source sets
sourceSets {
    main {
        proto {
            // Tell Gradle's Protobuf Plugin to look in the buf-exported folder
            srcDir bufExportDir
        }
        resources {
            // Add the generated descriptor set to resources
            srcDir layout.buildDirectory.dir("generated/resources/proto/main")
        }
    }
    test {
        resources {
            // Also add descriptor files to test resources so WireMock can find them in tests
            srcDir layout.buildDirectory.dir("generated/resources/proto/main")
        }
    }
}

// Configure IntelliJ IDEA to recognize generated sources
idea {
    module {
        sourceDirs += file('build/generated/sources/proto/main/java')
        sourceDirs += file('build/generated/sources/proto/main/grpc')
        generatedSourceDirs += file('build/generated/sources/proto/main/java')
        generatedSourceDirs += file('build/generated/sources/proto/main/grpc')
    }
}

// Configure Eclipse to recognize generated sources
eclipse {
    classpath {
        file {
            whenMerged { classpath ->
                // Add generated protobuf sources to Eclipse classpath
                def generatedJava = new org.gradle.plugins.ide.eclipse.model.SourceFolder(
                    'build/generated/sources/proto/main/java', null)
                def generatedGrpc = new org.gradle.plugins.ide.eclipse.model.SourceFolder(
                    'build/generated/sources/proto/main/grpc', null)
                classpath.entries.add(generatedJava)
                classpath.entries.add(generatedGrpc)
            }
        }
    }
}

tasks.named('processResources').configure {
    dependsOn 'generateProto'
    // Copy descriptor file to src/main/resources/META-INF/grpc so Jib will include it
    doLast {
        def descriptorFile = file("src/test/resources/wiremock/grpc/services.dsc")
        if (descriptorFile.exists()) {
            copy {
                from descriptorFile
                into "src/main/resources/META-INF/grpc"
                rename { "services.dsc" }
            }
        }
    }
}

// Shadow JAR configuration for Docker container
shadowJar {
    archiveClassifier = ''
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'ai.pipestream.wiremock.server.Main'
    }
}

// Disable default JAR and use shadow JAR instead
jar {
    enabled = false
}

// Make assemble depend on shadow JAR
assemble.dependsOn shadowJar

// Copy resources to build/libs/resources for Docker
tasks.register('copyResourcesForDocker', Copy) {
    from 'src/main/resources'
    into 'build/libs/resources'
}
shadowJar.dependsOn copyResourcesForDocker

tasks.named('processTestResources').configure {
    dependsOn 'generateProto', 'generateTestProto'
    // Copy descriptor file to test resources wiremock/grpc so WireMock gRPC extension can find it in tests
    // WireMock expects it at src/test/resources/wiremock/grpc/services.dsc when using withRootDirectory
    doLast {
        def descriptorFile = file("${buildDir}/generated/sources/proto/main/descriptor_set.desc")
        if (descriptorFile.exists()) {
            // Copy to wiremock/grpc directory for withRootDirectory approach
            copy {
                from descriptorFile
                into "${projectDir}/src/test/resources/wiremock/grpc"
                rename { "services.dsc" }
            }
            // Also copy to META-INF/grpc for classpath approach (if needed)
            copy {
                from descriptorFile
                into "${buildDir}/resources/test/META-INF/grpc"
                rename { "services.dsc" }
            }
        }
        // Copy ServiceLoader service file to test resources
        def serviceFile = file("${projectDir}/src/main/resources/META-INF/services/ai.pipestream.wiremock.client.ServiceMockInitializer")
        if (serviceFile.exists()) {
            copy {
                from serviceFile
                into "${projectDir}/src/test/resources/META-INF/services"
            }
        }
    }
}

// Wire up task dependencies
// Before you generate Java code, you must fetch the protos from Buf
tasks.named('generateProto').configure {
    dependsOn 'syncProtos'

    doFirst {
        mkdir layout.buildDirectory.dir("generated/resources/proto/main/META-INF/grpc").get().asFile
    }
}

// Explicit dependencies to resolve Gradle 8+ validation errors
tasks.withType(Jar).configureEach {
    dependsOn 'generateProto'
}
tasks.withType(Javadoc).configureEach {
    dependsOn 'generateProto'
}

application {
    mainClass = 'ai.pipestream.wiremock.server.Main'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
    withJavadocJar()
    withSourcesJar()
}

compileJava {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-parameters'
}

test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
    }
}

// Configure Javadoc task
tasks.withType(Javadoc).configureEach { task ->
    def opts = task.options
    opts.encoding = 'UTF-8'
    opts.charSet = 'UTF-8'
    opts.locale = 'en'
    if (opts instanceof StandardJavadocDocletOptions) {
        opts.addBooleanOption('html5', true)
    }
    // Suppress missing Javadoc warnings for now to ensure build passes but produces valid artifacts
    opts.addStringOption('Xdoclint:-missing', '-quiet')
    
    // Exclude generated protobuf code from Javadoc
    task.exclude('**/ai/pipestream/platform/registration/**')
    task.exclude('**/ai/pipestream/data/**')
    task.exclude('**/ai/pipestream/opensearch/**')
    task.exclude('**/com/google/**')
}

// Publishing configuration
publishing {
    publications {
        create('maven', MavenPublication) {
            from components.java
            pom {
                name.set('Pipestream WireMock Server')
                description.set('Standalone WireMock server with gRPC extension and custom streaming support for Pipestream')
                url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')

                licenses {
                    license {
                        name.set('MIT License')
                        url.set('https://opensource.org/license/mit')
                    }
                }

                developers {
                    developer {
                        id.set('krickert')
                        name.set('Pipestream Engine Team')
                    }
                }

                scm {
                    connection.set('scm:git:git://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    developerConnection.set('scm:git:ssh://github.com/ai-pipestream/pipestream-wiremock-server.git')
                    url.set('https://github.com/ai-pipestream/pipestream-wiremock-server')
                }
            }
        }
    }

    repositories {
        mavenLocal()
        
        def ghRepo = System.getenv('GITHUB_REPOSITORY') ?: 'ai-pipestream/pipestream-wiremock-server'
        def ghActor = System.getenv('GITHUB_ACTOR') ?: System.getenv('GPR_USER')
        def ghToken = System.getenv('GITHUB_TOKEN') ?: System.getenv('GPR_TOKEN')
        
        if (ghActor && ghToken) {
            maven {
                name = 'GitHubPackages'
                url = uri("https://maven.pkg.github.com/${ghRepo}")
                credentials {
                    username = ghActor
                    password = ghToken
                }
            }
        }
    }
}

signing {
    def signingKey = System.getenv("GPG_PRIVATE_KEY")
    def signingPassword = System.getenv("GPG_PASSPHRASE")

    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.maven
    }
}

// Ensure all signing tasks run before nmcp bundles and publishes artifacts
afterEvaluate {
    tasks.matching { it.name.startsWith("nmcpZipAllPublications") || it.name.startsWith("nmcpPublishAllPublicationsToCentralPortal") }
        .configureEach { nmcpTask ->
            nmcpTask.dependsOn(tasks.withType(Sign))
        }
}

nmcp {
    publishAllPublicationsToCentralPortal {
        username = providers.environmentVariable("MAVEN_CENTRAL_USERNAME")
        password = providers.environmentVariable("MAVEN_CENTRAL_PASSWORD")
        publishingType = "AUTOMATIC"
    }
}

